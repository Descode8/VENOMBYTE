/*
██╗   ██╗███████╗███╗   ██╗ ██████╗ ███╗   ███╗██████╗ ██╗   ██╗████████╗███████╗
██║   ██║██╔════╝████╗  ██║██╔═══██╗████╗ ████║██╔══██╗╚██╗ ██╔╝╚══██╔══╝██╔════╝
██║   ██║█████╗  ██╔██╗ ██║██║   ██║██╔████╔██║██████╔╝ ╚████╔╝    ██║   █████╗  
╚██╗ ██╔╝██╔══╝  ██║╚██╗██║██║   ██║██║╚██╔╝██║██╔══██╗  ╚██╔╝     ██║   ██╔══╝  
 ╚████╔╝ ███████╗██║ ╚████║╚██████╔╝██║ ╚═╝ ██║██████╔╝   ██║      ██║   ███████╗
  ╚═══╝  ╚══════╝╚═╝  ╚═══╝ ╚═════╝ ╚═╝     ╚═╝╚═════╝    ╚═╝      ╚═╝   ╚══════╝      
*/

///////////////////////////////////////////////////////////// MODS ////////////////////////////////////////////////////////////////////
/*
AIM SNAP
Description: Snaps your aim toward the nearest target within a small field of view for quicker target acquisition.

AIM ASSIST
Description: Adds subtle left/right stick movement while aiming to make the in-game aim assist bubble feel stronger and “stickier.”

STICKY AIM
Description: Creates a tight lock-on effect by constantly pulling your crosshair toward targets and keeping it inside the hitbox.

RECOIL CONTROL
Description: Applies downward stick movement to automatically reduce weapon recoil when firing.

BUNNY HOP
Description: Automatically performs timed jumps while firing from the hip, keeping you mobile and harder to hit.

PING ENEMY
Description: Rapidly taps the ping button while shooting so enemies get marked more easily.

HOLD BREATH (Sniper Apnea)
Description: Automatically holds breath when aiming with a sniper to steady your scope without extra button presses.

RAPIDFIRE
Description: Converts semi-automatic weapons into full-auto by pressing fire rapidly at a set speed.

KILLSHOTZ
Description: Adds micro-movements when firing inside a close radius to increase hit registration on enemies.

SLIDE HOP (if you enable it)
Description: Triggers a jump right as a slide ends, letting you chain slides into hops for faster evasive movement.

RUN COMBO (if you enable it)
Description: While moving fully forward (LS ≈ 100) and not pressing RT/LT, auto-cycles run 2s → slide → hop → repeat for continuous evasive movement.
*/
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* 
////////////// CROSS-PLATFORM INPUT ALIASES AND BUTTONS ////////////////////////
PURPOSE:
    DECLARE GENERIC INPUT VARIABLES (TRIGGERS, STICKS, DPAD, ACTION BUTTONS).
WHY:
    YOUR SCRIPT MAPS BUTTONS DYNAMICALLY (PS/XBOX) IN setup_controls(); THESE
    ALIASES LET EVERYTHING ELSE USE A SINGLE, CONSISTENT SET OF NAMES.
SIDE EFFECTS:
    NONE HERE—ONLY DECLARATIONS; VALUES ARE ASSIGNED IN setup_controls().
*/
int Fire, Aim, Sprint;
int aim_x, aim_y;
int BTN_MELEE, BTN_TACTICAL, BTN_LETHAL;
int Crouch, BTN_JUMP;
int BTN_MENU, BTN_SHARE;       // OPTIONS/MENU and SHARE/VIEW
int BTN_UP, BTN_DOWN, BTN_LEFT, BTN_RIGHT;
int BTN_R3;
int moveLX, moveLY;
int Ping;

/* 
////////////// POLAR STICK ALIASES (PLATFORM-AGNOSTIC) /////////////////////////
PURPOSE:
    POLAR COORDINATE ACCESSORS FOR THE RIGHT STICK (MAGNITUDE+ANGLE).
WHY:
    SOME MODS (KILLSHOTZ/POLAR ASSIST) OPERATE BETTER IN POLAR SPACE.
*/
define PS = POLAR_RS;
define PX = POLAR_RX;
define PY = POLAR_RY;
define KEEP_BRAND = 1;

/* 
////////////// ADJUSTABLE VARIABLES: RUNTIME-TUNED PARAMETERS ///////////////////
PURPOSE:
    HOLDS ALL USER-TUNABLE PARAMETERS (AA SPEED/WIDTH, RECOIL, BUNNY HOP TIMING).
EDITOR:
    THESE VALUES ARE SURFACED IN THE OLED EDITOR UI; BOUNDS IN ValRange[][].
PERSISTENCE:
    MOST ARE SAVED/LOADED VIA SPVAR IN init() AND save_toggles().
*/
int adjust_variable_idx;                  
int aimSnap_resolution; 
int input_deadzone;
int aimAssist_vmSpeed; 
int aimAssist_width; 
int aimAssist_vertical;  
int aimAssist_size;  
int aimAssist_time;
int stickyAim_size; 
int stickyAim_speed; 
int recoil_y_compensation;  
int bunnyHop_delayMultiplier; 
int bunnyHop_timing_ms; 
int aaBooster_frequency; 
int aaBooster_delay_ms; 
int userHotkeyCode; 
int param_slot_a;     
int param_slot_b;           
int polarAssist_radius; 
int pingCooldown_ms; 
int rapidFire_on_ms;
int rapidFire_off_ms; 
int rapidFire_release_ms;    

/* 
////////////// MENU & FEATURE INDICES (PAGES / ROUTING) ////////////////////////
PURPOSE:
    CONSTANTS THAT MAP "MENU PAGE" → FEATURE. CONTROLS NAVIGATION & RENDERING.
NOTES:
    ABOUT_IDX DEFINES A READ-ONLY PAGE. MAX_MODS_COUNT ADDS WRAP-AROUND SPACE.
*/
define EDIT_COUNT               = 21;                   
define AMOUNT_OF_VALNAME_IDX    = 22; 
define MAX_MODS_COUNT           = 15;     
define ABOUT_IDX                = 15;          // new About page index      
define IDX_RECOIL_CONTROL       = 0;
define IDX_AIM_SNAP             = 1;
define IDX_AIM_ASSIST           = 3;
define IDX_STICKY_AIM           = 4;
define IDX_BUNNY_HOP            = 8;
define IDX_RUN_COMBO            = 9;
define IDX_PING_ENEMY           = 10;
define IDX_HOLD_BREATH          = 11;
define IDX_RAPIDFIRE            = 12;
define IDX_VMSPEED              = 13;
define IDX_SLIDE_HOP            = 14;
define On                       = 1;
define Off                      = 0;

/* 
////////////// TOGGLE STATES AND MENU NAVIGATION ///////////////////////////////
PURPOSE:
    RUNTIME TOGGLES (ON/OFF) FOR EACH MOD + CURRENT MENU PAGE STATE.
USAGE:
    MUTATED BY set_option_value(), UI EVENTS, AND INIT DEFAULTS.
PERSISTENCE:
    MOST ARE SYNCED TO SPVAR SO THEY SURVIVE REBOOTS.
*/
int menuPage_idx;  
int recoilControl_on; 
int aimSnap_enabled;  
int stickNoiseFilter_on;  
int aimAssist_mode; 
int stickyAim_on; 
int killshotz_on;
int bunnyHop_on;
int runCombo_on; 
int slideHop_on;
int pingEnemy_on;
int sniperApnea_on;
int rapidFire_on;
int rapidFire_speedProfile;
int edit_tmp_val, tmp_val;
int int_controller, out_console;

/* 
////////////// UI STRINGS: MOD NAMES / LABELS / PRODUCT INFO ///////////////////
PURPOSE:
    USER-FACING NAMES SHOWN ON THE OLED. KEEP SHORT TO AVOID WRAP.
NOTES:
    CHANGING TEXT ONLY UPDATES UI—LOGIC KEYS (INDICES/TOGGLES) LIVE ELSEWHERE.
*/
const string RECOIL_CONTROL     = "RECOIL CONTROL" ;
const string AIM_ASSIST         = "AIM ASSIST" ;
const string TRACKERMOD         = "STICKY AIM" ; 
const string BUNNY_HOP		    = "BUNNY HOP" ;
const string RUN_COMBO          = "RUN COMBO" ;
const string PING			    = "PING ENEMY" ;
const string HOLD			    = "SNIPER APNEA" ;
const string RAPIDFIRE          = "RAPID FIRE" ;
// const string SLIDE_HOP         = "SLIDE HOP" ;
const string OFF			    = "OFF" ;    
const string ON			        = "ON" ;   
const string SCRIPT_ONOFF       = "EVILBOTv3";   
const int8 ASCII_NUM[]          = {48,49,50,51,52,53,54,55,56,57};  

const string NO_EDIT_VAR1       = "VENOMBYTE";
const string NO_EDIT_VAR2       = "VENOMBYTE";
const string NO_EDIT_VAR3       = "   v1.0";

const string STR_PRODUCT_NAME   = "VENOMBYTE";
const string STR_PRODUCT_VER    = "v1.0";


/* 
////////////// OPTIONS TABLE: PAGE → OPTION FAMILY (1/31/50/…) //////////////////
PURPOSE:
    CONTROLS WHAT TYPE OF VALUE THE PAGE DISPLAYS:
        1  = SIMPLE ON/OFF
        31 = SHOT MODE SELECTOR (OFF/SINGLE/AIM+SHOT/JUST POINTED/IN SHOOTING)
        50 = VM SPEED PRESETS (DEFAULT/8MS/…)
IMPACT:
    display_mod() USES THIS TO CHOOSE WHICH TEXT/CHOICES TO RENDER.
*/
const uint8 Options [] = {
    1,  // 0 RECOIL CONTROL
    1,  // 1 AIM SNAP
    1,  // 2
    31, // 3 AIM ASSIST (ShotModOptions)
    1,  // 4 TRACKERMOD
    1,  // 5 KILLSHOTZ
    69, // 6
    1,  // 7 HEADSHOT
    1,  // 8 BUNNY HOP
    1,  // 9 RUN COMBO
    1,  // 10 PING
    1,  // 11 HOLD
    1,  // 12 RAPIDFIRE (ON/OFF)
    50, // 13 VMSPEED
    1,  // 14
    0   // 15 ABOUT page (no options)
};

/* 
////////////// EDITABILITY TABLE: PAGE → (1=EDITABLE, 0=READ-ONLY) //////////////
PURPOSE:
    FLAGS WHICH PAGES OPEN THE NUMERIC EDITOR (ARROWS, MIN/MAX).
USAGE:
    WHEN 0, THE PAGE SHOWS STATUS ONLY (E.G., ABOUT PAGE).
*/
const uint8 EditVal [] = { 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 };

/* 
////////////// INDEX RANGE PER PAGE FOR THE VALUE EDITOR ////////////////////////
PURPOSE:
    BOUNDS FOR adjust_variable_idx WITHIN EACH PAGE (FIRST..LAST EDITABLE FIELD).
WHY:
    PREVENTS EDITOR FROM SELECTING FIELDS NOT MEANT FOR THAT PAGE.
*/
const uint8 OptRange [][] = {
    { 9, 9 },  // 0
    { 0, 0 },  // 1
    { 1, 1 },  // 2
    { 2, 6 },  // 3
    { 0, 0 },  // 4
    { 17, 17 },// 5
    { 14, 16 },// 6
    { 0, 0 },  // 7
    { 0, 0 },  // 8
    { 0, 0 },  // 9
    { 0, 0 },  // 10
    { 0, 0 },  // 11
    { 0, 0 },  // 12
    { 0, 0 },  // 13
    { 0, 0 },  // 14
    { 0, 0 }   // 15 ABOUT (no editor)
};

/* 
////////////// MIN/MAX OPTION CYCLING LIMITS PER PAGE ///////////////////////////
PURPOSE:
    LEFT/RIGHT OPTION RANGES FOR EACH PAGE (E.G., 0..1 FOR ON/OFF).
USAGE:
    f_go_forward()/f_go_back() WRAP WITHIN THESE LIMITS.
*/
const uint8 Min_Max_Options [][] = {
    {0,1}, // 0
    {0,1}, // 1
    {0,1}, // 2
    {0,2}, // 3
    {0,1}, // 4
    {0,1}, // 5
    {0,3}, // 6
    {0,1}, // 7
    {0,1}, // 8
    {0,1}, // 9
    {0,1}, // 10
    {0,1}, // 11
    {0,1}, // 12
    {0,5}, // 13
    {0,1}, // 14
    {0,0}  // 15 ABOUT (no options)
};

/* 
////////////// EDITOR LABEL STRINGS FOR EACH EDITABLE VALUE /////////////////////
PURPOSE:
    OLED LABELS FOR THE CURRENTLY ACTIVE EDIT FIELD (E.G., "VM SPEED", "TIME").
UX:
    SHOWN BY HOTHACKER54545() AT THE TOP OF THE EDITOR SCREEN.
*/
const string EditVarStr []={
    "Evilbot AIM.A", 
    "Evilbot2233",  
    "Vm Speed",
    "Width Shape",
    "Vertical",
    "Size",
    "Time",
    "Size",
    "Time",
    " Vertical Recoil",
    "Time Start",
    "Time",
    "Size",
    "Time",
    "Radius",
    "Speed",     
    "NOTORIOUS",         
    "Width Shape", 
    "Delay",
    "FR Speed", 
    "FR Release"  
};


/* 
////////////// GLOBAL SCREEN / TIMEOUT CONSTANTS ////////////////////////////////
PURPOSE:
    UI TIMEOUTS & SLEEP SETTINGS (MS). CONTROLS SAVER AND AUTO-CLEAR.
*/
define Screen_Sleep_Time = 5000;
define TimeoutLimit      = 30000;

/* 
////////////// MISC UI STRINGS FOR SAVER / BRANDING /////////////////////////////
PURPOSE:
    SHORT TEXTS SHOWN BY THE SCREENSAVER (PRODUCT NAME / VERSION).
*/
const string MiscString[] = {
    "VERSION 1.0",
    "VENOMBYTE"
};

/* 
////////////// STICKY AIM: FORCE PRESET ON (LOCK + PERSIST) /////////////////////
PURPOSE:
    GUARANTEE STICKY AIM IS ENABLED AT A KNOWN GOOD PRESET (SIZE=18, SPEED=90).
PERSISTENCE:
    WRITES SPVAR_4/13/14 SO THE PRESET SURVIVES POWER CYCLES.
SIDE EFFECTS:
    OVERRIDES CURRENT STICKY SETTINGS WHEN CALLED.
*/
function trackermod_lock_on() {
    stickyAim_on = 1;   //STICKY AIM ON
    stickyAim_size  = 18;  // Size
    stickyAim_speed  = 90;  // Speed

    // persist these so they survive reboots
    set_pvar(SPVAR_4,  1);   //STICKY AIM ON
    set_pvar(SPVAR_13, 18);  // Size
    set_pvar(SPVAR_14, 90);  // Speed
}

/* 
////////////// STICKY AIM: APPLY/REMOVE PRESET AND PERSIST //////////////////////
PURPOSE:
    TURN STICKY AIM ON/OFF. WHEN ENABLING, ENFORCE KNOWN PRESET; WHEN DISABLING,
    LEAVE SIZE/SPEED VALUES UNTOUCHED BUT SAVE THE TOGGLE STATE.
*/
function trackermod_apply(int on) {
    if (on) {
        stickyAim_on = 1;   // ON
        stickyAim_size  = 18;  // Size
        stickyAim_speed  = 90;  // Speed
        set_pvar(SPVAR_4,  1);   // persist ON
        set_pvar(SPVAR_13, 18);  // persist Size
        set_pvar(SPVAR_14, 90);  // persist Speed
    } else {
        stickyAim_on = 0;   // OFF
        set_pvar(SPVAR_4,  0);   // persist OFF
        // (no need to touch SPVAR_13/14 when OFF)
    }
}

/* 
////////////// KILLSHOTZ: FORCE ON AND PERSIST //////////////////////////////////
PURPOSE:
    KEEP KILLSHOTZ ALWAYS ENABLED, EVEN IF USER TRIES TO DISABLE IT.
WHEN:
    CALLED DURING INIT AND WHEN OPTION CHANGES TO RE-ASSERT STATE.
*/
function killshotz_force_on() {
    killshotz_on = 1;      // ON
    set_pvar(SPVAR_26, 1);       // persist ON
}

/* 
////////////// CONTROLLER/CONSOLE DETECTION AND BUTTON MAPPING //////////////////
PURPOSE:
    RUNTIME DETECTION OF OUTPUT CONSOLE & INPUT PAD; MAPS GENERIC ALIASES
    (Fire/Aim/etc.) TO THE CORRECT PLATFORM BUTTONS (PS/XBOX).
IMPACT:
    MAKES THE REST OF THE SCRIPT PLATFORM-AGNOSTIC.
*/
function setup_controls() {
    out_console = get_console();        // What Zen is plugged into -> OUTPUT: PIO_PS4 / PIO_PS5 / PIO_XB1 / etc.
    int_controller = get_controller();  // What is plugged into Zen ->INPUT: physical pad type (optional)

    if (out_console == PIO_XB1) { // Xbox One / Series
        Fire        = XB1_RT; // Right Trigger
        Aim         = XB1_LT; // Left Trigger
        Sprint      = XB1_LS; // Left Stick Click
        aim_x       = XB1_RX; // Right Stick X-axis
        aim_y       = XB1_RY; // Right Stick Y-axis
        BTN_MELEE   = XB1_B;  // B button
        BTN_TACTICAL= XB1_LB; // Left Bumper
        BTN_LETHAL  = XB1_RB; // Right Bumper
        Crouch      = XB1_B;  // B button
        BTN_JUMP    = XB1_A;  // A button
        BTN_MENU    = XB1_MENU;   // ≈ OPTIONS
        BTN_SHARE   = XB1_VIEW;   // ≈ SHARE
        moveLX      = XB1_LX; // Left Stick X-axis
        moveLY      = XB1_LY; // Left Stick Y-axis
        Ping        = XB1_UP; // D-pad Up
        BTN_UP      = XB1_UP;
        BTN_LEFT    = XB1_LEFT;
        BTN_RIGHT   = XB1_RIGHT;
        BTN_DOWN    = XB1_DOWN;
        
    } else { // PS4 fallback
        Fire        = PS4_R2; // Right Trigger
        Aim         = PS4_L2; // Left Trigger
        Sprint      = PS4_L3; // Left Stick Click
        aim_x       = PS4_RX; // Right Stick X-axis
        aim_y       = PS4_RY; // Right Stick Y-axis
        BTN_MELEE   = PS4_CIRCLE; // Circle button
        BTN_TACTICAL= PS4_L1; // Left Bumper
        BTN_LETHAL  = PS4_R1; // Right Bumper
        Crouch      = PS4_CIRCLE; // Circle button
        BTN_JUMP    = PS4_CROSS; // Cross button
        BTN_MENU    = PS4_OPTIONS; // OPTIONS button
        BTN_SHARE   = PS4_SHARE; // SHARE button
        moveLX      = PS4_LX; // Left Stick X-axis
        moveLY      = PS4_LY; // Left Stick Y-axis
        Ping        = PS4_UP; // D-pad Up
        BTN_UP      = PS4_UP; 
        BTN_LEFT    = PS4_LEFT;
        BTN_RIGHT   = PS4_RIGHT;
        BTN_DOWN    = PS4_DOWN;
    }

    MenuButtons[0] = BTN_RIGHT;
    MenuButtons[1] = BTN_LEFT;
    MenuButtons[2] = BTN_UP;
    MenuButtons[3] = BTN_DOWN;
    MenuButtons[4] = BTN_JUMP;
    MenuButtons[5] = BTN_MELEE;
    MenuButtons[6] = BTN_MENU;
    MenuButtons[7] = Aim;
}

/* 
////////////// INIT: LOAD DEFAULTS/PVARS, PRECOMPUTE, CLEAR OLED ///////////////
PURPOSE:
    SET INITIAL TOGGLES, LOAD PERSISTED VALUES (SPVAR), CALCULATE DERIVEDS,
    CLEAR THE OLED, AND READY ALL MODS FOR MAIN().
ORDER MATTERS:
    SET ALL PDEPENDENCIES (E.G., AIM ASSIST MODE) BEFORE COMPUTING DERIVATIVES.
*/
init {
    setup_controls();   // call this for cross-platform support
    // ================= AIM / ASSIST DEFAULTS =================
    aimSnap_enabled             = 1;                          // AIM SNAP toggle (1 = ON by default)
    stickNoiseFilter_on         = get_pvar(SPVAR_2,  0, 1, 0); // General ON/OFF state storage
    aimAssist_mode              = get_pvar(SPVAR_3, 0, 2, 2);  // AIM ASSIST mode (0=off, 1=ON, 2=Aim+Shot default)
    aim_assist_set_onoff(1);                               // Force AIM ASSIST to default ON (mode = Aim+Shot)
    
    // ================= MOVEMENT MODS =================
    slideHop_on                 = 0;                          // SLIDE HOP default OFF
    trackermod_lock_on();                                     // STICKY AIM lock ON at preset (Size=18, Speed=90)
    recoilControl_on            = 1;                          // RECOIL CONTROL default ON
    bunnyHop_on                 = 1;                          // BUNNY_HOP default ON
    runCombo_on                 = get_pvar(SPVAR_38, 0, 1, 1);                          // RUN COMBO default ON

    // ================= OTHER CORE MODS =================
    killshotz_on                = get_pvar(SPVAR_26, 0, 1, 1); // KILLSHOTZ default ON
    killshotz_force_on();                                     // Ensure KILLSHOTZ is always ON/persisted
    pingEnemy_on                = 1;                          // PING ENEMY default ON
    sniperApnea_on              = 1;                          // HOLD BREATH (SNIPER APNEA) default ON
    rapidFire_on                = 0;                          // RAPIDFIRE default ON
    rapidFire_speedProfile      = get_pvar(SPVAR_35, 1, 5, 0); // RAPIDFIRE speed profile

    // ================= AIM SNAP SETTINGS =================
    aimSnap_resolution          = 3;                          // AIM SNAP FOV (default 3)
    input_deadzone              = 11;                         // Deadzone threshold
    aimAssist_vmSpeed           = 23;                         // AIM ASSIST VM Speed (default 50)
    aimAssist_width             = 7;                          // AIM ASSIST Width Shape
    aimAssist_vertical          = 5; // Vertical adjustment
    aimAssist_size              = 4; // Size
    aimAssist_time              = 8; // Time
    
    // ================= TRACKER / STICKY AIM SETTINGS =================
    stickyAim_size              = 18; // STICKY AIM Size
    stickyAim_speed             = 45; // STICKY AIM Speed
    
    // ================= RECOIL CONTROL =================
    recoil_y_compensation       = 22;                                                    // Vertical Recoil default
    bunnyHop_delayMultiplier    = get_pvar(SPVAR_17, 1, 10, 1);   // Bunny Hop: delay multiplier
    bunnyHop_timing_ms          = get_pvar(SPVAR_18, 1, 999, 100);// Bunny Hop: crouch/jump timing
    aaBooster_frequency         = get_pvar(SPVAR_20, 1, 99, 5);   // AA booster: jitter frequency
    aaBooster_delay_ms          = get_pvar(SPVAR_21, 1, 2000, 1500); // AA booster: jitter delay
    
    // ================= HOTKEYS & EXTRA VARIABLES =================
    userHotkeyCode              = get_pvar(SPVAR_23, 1, 100, 13); // Custom hotkey #19
    param_slot_a                = get_pvar(SPVAR_24, 1, 100, 50); // General param slot
    param_slot_b                = get_pvar(SPVAR_25, 1, 100, 9);  // General param slot
    polarAssist_radius          = 10;                                                    // Polar Aim Assist radius
    
    // ================= TIMINGS (RAPID FIRE) =================
    pingCooldown_ms             = get_pvar(SPVAR_30, 1, 2000, 1000); // Ping cooldown
    rapidFire_on_ms             = get_pvar(SPVAR_33, 1, 1000, 4);    // AA random offset
    rapidFire_off_ms            = get_pvar(SPVAR_34, 1, 1000, 7);    // RAPID FIRE speed (ms between shots)
    rapidFire_release_ms        = get_pvar(SPVAR_37, 1, 100,  22);   // RAPID FIRE release (ms)
    
    // ================= GENERAL =================
    slot_numb = get_slot();                                     // Current slot number on Zen device


    // active_aiming depends on aimAssist_vmSpeed/89099 already loaded above
    active_aiming = (((360 + aimAssist_vmSpeed) / aimAssist_vmSpeed) + 1) * aimAssist_vertical;

    cls_oled(0);
}

/* 
////////////// GLOBALS: LED FADE / MATH / AIM STATE / TRACKER ANGLE ////////////
PURPOSE:
    SHARED STATE FOR ANIMATIONS, AA MOTION, ANGLES, AND COUNTERS.
NOTE:
    active_aiming/COUNTER + toggle_active_aiming DRIVE PATTERN FLIPS IN Soft_Aim().
*/
int SaverOn = TRUE;
int Timer;
int NotoriouscriptzVIP_x, NotoriouscriptzVIP_y;
int NotoriouscriptzVIP_t;
int NotoriouscriptzVIP_c = 1;
int X;
int CurRX, CurRY;
int CurrentRX, CurrentRY;
int ReT;
int anti_recoil_y;
int lx_aim, ly_aim;
int input_mag;
int first_aim;
int aim_speed, aim_width;
int active_aiming_counter, active_aiming;
int _angle;
int toggle_active_aiming = 1;
int TrackerAngle = 270;


define killshotz_on_Polar = 0;
int killshotz_on_Reducer = 1;
int PolarValue = 32767;
int PolarVIAssist = 1;
int TimeToShowIntroPicture = 30000;
int KILLSHOTZVIAngle;
int VISpeed;
int PolarAngle = 30; // balanced default
int display_black,count_black;
int CountLED;
int RED1;
int BLUE1;
int GREEN1;
int RED=1;
int GREEN=1;
int BLUE=1;

/* 
////////////// EDITOR: READ CURRENT VALUE BY INDEX //////////////////////////////
PURPOSE:
    MAPS adjust_variable_idx → THE ACTUAL VARIABLE VALUE TO DISPLAY/EDIT.
RETURNS:
    INTEGER IN CURRENT UNITS, BOUNDED LATER BY ValRange[][] IN edit_val().
*/
function get_edit_value(int ix) {
    if (ix == 0)  return aimSnap_resolution;
    if (ix == 1)  return input_deadzone;
    if (ix == 2)  return aimAssist_vmSpeed;
    if (ix == 3)  return aimAssist_width;
    if (ix == 4)  return aimAssist_vertical;
    if (ix == 5)  return aimAssist_size;
    if (ix == 6)  return aimAssist_time;
    if (ix == 7)  return stickyAim_size;
    if (ix == 8)  return stickyAim_speed;
    if (ix == 9)  return recoil_y_compensation;
    if (ix == 10) return bunnyHop_delayMultiplier;
    if (ix == 11) return bunnyHop_timing_ms;
    if (ix == 12) return aaBooster_frequency;
    if (ix == 13) return aaBooster_delay_ms;
    if (ix == 14) return polarAssist_radius;
    if (ix == 15) return param_slot_a;
    if (ix == 16) return param_slot_b;
    if (ix == 17) return pingCooldown_ms;
    if (ix == 18) return rapidFire_on_ms;
    if (ix == 19) return rapidFire_off_ms;
    if (ix == 20) return rapidFire_release_ms;
    return 0;
}

/* 
////////////// EDITOR: WRITE NEW VALUE BY INDEX /////////////////////////////////
PURPOSE:
    MAPS adjust_variable_idx → ASSIGN THE USER-EDITED VALUE BACK TO STORAGE.
VALIDATION:
    CALLER ENSURES BOUNDS VIA edit_val() BEFORE THIS WRITE.
*/
function set_edit_value(int ix, int v) {
    if (ix == 0)  { aimSnap_resolution            = v; return; }
    if (ix == 1)  { input_deadzone             = v; return; }
    if (ix == 2)  { aimAssist_vmSpeed            = v; return; }
    if (ix == 3)  { aimAssist_width             = v; return; }
    if (ix == 4)  { aimAssist_vertical             = v; return; }
    if (ix == 5)  { aimAssist_size             = v; return; }
    if (ix == 6)  { aimAssist_time             = v; return; }
    if (ix == 7)  { stickyAim_size            = v; return; }
    if (ix == 8)  { stickyAim_speed            = v; return; }
    if (ix == 9)  { recoil_y_compensation             = v; return; }
    if (ix == 10) { bunnyHop_delayMultiplier              = v; return; }
    if (ix == 11) { bunnyHop_timing_ms             = v; return; }
    if (ix == 12) { aaBooster_frequency            = v; return; }
    if (ix == 13) { aaBooster_delay_ms             = v; return; }
    if (ix == 14) { polarAssist_radius                      = v; return; }
    if (ix == 15) { param_slot_a                = v; return; }
    if (ix == 16) { param_slot_b           = v; return; }
    if (ix == 17) { pingCooldown_ms    = v; return; }
    if (ix == 18) { rapidFire_on_ms        = v; return; }
    if (ix == 19) { rapidFire_off_ms          = v; return; }
    if (ix == 20) { rapidFire_release_ms              = v; return; }
}

/* 
////////////// READ CURRENT OPTION/TOGGLE FOR ACTIVE PAGE ///////////////////////
PURPOSE:
    PROVIDE CURRENT TOGGLE/OPTION VALUE FOR display_mod().
SPECIAL:
    AIM ASSIST PAGE EXPOSES "ON" ONLY WHEN INTERNAL MODE == AIM+SHOT (2).
*/
function get_option_value(int ix) {
    if (ix == IDX_RECOIL_CONTROL) return recoilControl_on;
    if (ix == IDX_AIM_SNAP)       return aimSnap_enabled;
    // AIM ASSIST mode (0..2)
    if (ix == IDX_AIM_ASSIST) {
        if (aimAssist_mode == 2) {
            return 1; // ON
        } else {
            return 0; // OFF
        }
    }
    if (ix == IDX_STICKY_AIM)     return stickyAim_on;
    if (ix == 5)                  return killshotz_on; // KILLSHOTZ (kept)
    if (ix == IDX_BUNNY_HOP)      return bunnyHop_on;
    if (ix == IDX_RUN_COMBO)      return runCombo_on;
    if (ix == IDX_PING_ENEMY)     return pingEnemy_on;
    if (ix == IDX_HOLD_BREATH)    return sniperApnea_on;
    if (ix == IDX_RAPIDFIRE)      return rapidFire_on;
    if (ix == IDX_VMSPEED)        return rapidFire_speedProfile;
    if (ix == IDX_SLIDE_HOP)      return slideHop_on;   // <— NEW
    return 0;
}

/* 
////////////// APPLY OPTION/TOGGLE CHANGE FOR ACTIVE PAGE //////////////////////
PURPOSE:
    HANDLE SIDE-EFFECTS WHEN AN OPTION CHANGES (E.G., PERSIST, PRESET ENFORCE).
EFFECTS:
    SOME OPTIONS CALL HELPERS (trackermod_lock_on, aim_assist_set_onoff, ETC.).
*/
function set_option_value(int ix, int v) {
    if (ix == IDX_RECOIL_CONTROL) { recoilControl_on = v; return; }
    if (ix == IDX_AIM_SNAP)       { aimSnap_enabled = v; return; }

    if (ix == IDX_AIM_ASSIST) {
        if (v) { aim_assist_set_onoff(1); } else { aim_assist_set_onoff(0); }
        return;
    }

    if (ix == 4) {
        if (v) { trackermod_lock_on(); } else { trackermod_apply(0); }
        return;
    }

    if (ix == 5)               { killshotz_force_on(); return; } 
    if (ix == IDX_BUNNY_HOP)   { bunnyHop_on = v; return; }
    if (ix == IDX_RUN_COMBO)   { runCombo_on = v; return; }   // <<< NEW
    if (ix == IDX_PING_ENEMY)  { pingEnemy_on = v; return; }
    if (ix == IDX_HOLD_BREATH) { sniperApnea_on = v; return; }

    if (ix == IDX_RAPIDFIRE) {
        rapidFire_on = v;
        set_pvar(SPVAR_32, v);
        if (v) { rapidFire_off_ms = 7; rapidFire_release_ms = 22; set_pvar(SPVAR_34,7); set_pvar(SPVAR_37,22); }
        return;
    }

    if (ix == IDX_VMSPEED)   { rapidFire_speedProfile = v; return; }
    if (ix == IDX_SLIDE_HOP) { slideHop_on = v; return; }
}

/* 
////////////// MENU: DOES THIS PAGE HAVE A SCREEN? //////////////////////////////
PURPOSE:
    FILTERS NON-DISPLAY PAGES FROM NAVIGATION (E.G., UNUSED SLOTS).
*/
function has_page(int j) {
    return (j==IDX_RECOIL_CONTROL || j==IDX_AIM_ASSIST || j==IDX_STICKY_AIM ||
            j==IDX_BUNNY_HOP || j==IDX_RUN_COMBO || j==IDX_PING_ENEMY ||
            j==IDX_HOLD_BREATH || j==IDX_RAPIDFIRE /*|| j==IDX_SLIDE_HOP*/ ||
            j==ABOUT_IDX);
}

/* 
////////////// MENU: NEXT VALID PAGE (WRAP) /////////////////////////////////////
PURPOSE:
    MOVE FORWARD THROUGH PAGES UNTIL A DISPLAYABLE PAGE IS FOUND; WRAPS END→START.
*/
function next_index(int j) {
    // wrap forward through 0..MAX_MODS_COUNT until we land on a valid page
    do {
        j = (j + 1) % (MAX_MODS_COUNT + 1);
    } while (!has_page(j));
    return j;
}

/* 
////////////// MENU: PREVIOUS VALID PAGE (WRAP) //////////////////////////////////
PURPOSE:
    MOVE BACKWARD THROUGH PAGES UNTIL A DISPLAYABLE PAGE IS FOUND; WRAPS START→END.
*/
function prev_index(int j) {
    // wrap backward through 0..MAX_MODS_COUNT until we land on a valid page
    do {
        j = (j + MAX_MODS_COUNT) % (MAX_MODS_COUNT + 1); // effectively j-1 with wrap
    } while (!has_page(j));
    return j;
}

/* 
////////////// AIM ASSIST MASTER TOGGLE: PRESETS + PERSIST //////////////////////
PURPOSE:
    ENABLE/DISABLE AIM ASSIST. WHEN ENABLING, LOAD A TIGHT, STABLE PRESET AND
    WRITE SPVARS SO IT SURVIVES REBOOTS. WHEN DISABLING, ZERO THE MODE.
*/
function aim_assist_set_onoff(int on) {
    if (on) {
        // ON means the internal mode is "Aim + Shot" (=2)
        aimAssist_mode = 2;

        // Tight sticky bubble preset
        aimAssist_vmSpeed = 32;  // Vm Speed
        aimAssist_width   = 10;  // Width Shape
        aimAssist_vertical= 1;   // Vertical
        aimAssist_size    = 8;  // Size
        aimAssist_time    = 10;  // Time

        // Persist so they survive reboots
        set_pvar(SPVAR_3,  2);
        set_pvar(SPVAR_8,  30);
        set_pvar(SPVAR_9,  10);
        set_pvar(SPVAR_10, 7);
        set_pvar(SPVAR_11, 10);
        set_pvar(SPVAR_12, 12);
    } else {
        aimAssist_mode = 0;
        set_pvar(SPVAR_3, 0);
    }
}

/* 
////////////// MAIN LOOP: INPUT CONDITIONING, UI, MOD DISPATCH //////////////////
PURPOSE:
    PER-FRAME ENGINE. READS INPUTS, UPDATES UI, AND RUNS/STOP COMBOS.
ORDER:
    1) INPUT NORMALIZATION (DEADZONES, CLAMPS)
    2) MENU/EDITOR HANDLING
    3) FEATURE EXECUTION (RECOIL, AA, BUNNY HOP, KILLSHOTZ, ETC.)
PERF:
    KEEP EXPENSIVE BRANCHES GUARDED (event_* AND get_ival SHORT-CIRCUITS).
*/
main {
    if(RED==255){RED1=FALSE;}
    if(GREEN==255){GREEN1=FALSE;}
    if(BLUE==255){BLUE1=FALSE;}
    if(RED==1){RED1=TRUE;}
    if(GREEN==1){GREEN1=TRUE;}
    if(BLUE==1){BLUE1=TRUE;}
    CountLED = random(1,300);

	if(((CountLED)>=1) && (CountLED)<=100){
        if(RED1==TRUE){
            RED+=1;set_rgb(RED,GREEN,BLUE);
            CountLED = random(1,300);
        }
        if(RED1==FALSE){
            RED-=1;
            set_rgb(RED,GREEN,BLUE);
            CountLED = random(1,300);
        }
    }
	if(((CountLED)>=101) && (CountLED)<=200){
        if(GREEN1==TRUE){
            GREEN+=1;
            set_rgb(RED,GREEN,BLUE);
            CountLED = random(1,300);}
            if(GREEN1==FALSE){GREEN-=1;
            set_rgb(RED,GREEN,BLUE);
            CountLED = random(1,300);
            }
        }
	if(((CountLED)>=201) && (CountLED)<=300){
        if(BLUE1==TRUE){
            BLUE+=1;
            set_rgb(RED,GREEN,BLUE);
            CountLED = random(1,300);
        }if(BLUE1==FALSE){
            BLUE-=1;
            set_rgb(RED,GREEN,BLUE);
            CountLED = random(1,300);
            }
        }

    deadzone(Aim, Fire, 100, 100);

	if(get_ival(Aim) > 1)set_val(Aim, 100); 
	if(get_ival(Fire) > 1)set_val(Fire, 100); 

	if(get_console() == PIO_PS4)
    {
        if(get_controller() != PIO_PS4) 
        {
            if(get_ival(PS4_SHARE)) 
            {
                if(get_ival(PS4_R3)) 
                {
                    set_val(PS4_SHARE,100);
                    set_val(PS4_TOUCH,0);
                    set_val(PS4_R3,0);
                }
                else 
                {
                    set_val(PS4_TOUCH, 100);
                    set_val(PS4_SHARE, 0);
                }
            }
        }
    }
    else if(get_console() == PIO_XB360) 
    {
        if(get_controller() == PIO_PS4) 
            swap(PS4_TOUCH, PS4_SHARE);
    }
                                    
    
    if(get_ival(Aim)){
        if(event_press(PS4_SHARE)){
            HOTHACKER545459999    = !HOTHACKER545459999;
            cls_oled(0);
            draw_rectangle();
            
            display_mod( center_x(sizeof(SCRIPT_ONOFF)- 1, OLED_FONT_MEDIUM_WIDTH) ,SCRIPT_ONOFF [0],HOTHACKER545459999 ,1);
            HOTHACKER54545DDD = 2000;
                
            if(!HOTHACKER545459999) 
                set_Virtual_Machine_Speed(VM_Default); 
        }
    }
                            
    if(HOTHACKER54545DDD){
        HOTHACKER54545DDD -= get_rtime();
        if(HOTHACKER54545DDD <= 0) {
            cls_oled(0);    
        }
    }
                                

    if(HOTHACKER545459999){
                        
        if(HOTHACKER54545454 || HOTHACKE) 
            set_Virtual_Machine_Speed(VM_Default);
        if(HOTHACKER54545){                
                    
            cls_oled(0);                        
        
            if(EditVal[ menuPage_idx ] == 0 ){  
                                
                line_oled(1,45,127,45,1,0);    
                print( center_x( 10, OLED_FONT_SMALL_WIDTH ), 15, OLED_FONT_SMALL, OLED_WHITE, NO_EDIT_VAR1[0] ); 
                print( center_x(  6, OLED_FONT_SMALL_WIDTH ), 30, OLED_FONT_SMALL, OLED_WHITE, NO_EDIT_VAR2[0] );
                print( center_x(  8, OLED_FONT_SMALL_WIDTH ), 45, OLED_FONT_SMALL, OLED_WHITE, NO_EDIT_VAR3[0] );
                                                                                                            
            } else {
                // keep idx in bounds
                if (adjust_variable_idx < 0) adjust_variable_idx = 0;
                if (adjust_variable_idx >= EDIT_COUNT) adjust_variable_idx = EDIT_COUNT - 1;

                // draw the label line
                HOTHACKER54545( get_edit_value(adjust_variable_idx) );

                // read -> edit -> write back
                edit_tmp_val = get_edit_value(adjust_variable_idx);
                edit_tmp_val = edit_val(edit_tmp_val);
                set_edit_value(adjust_variable_idx, edit_tmp_val);
            }
        } 
        if(HOTHACK) { 
            cls_oled(0);       
            draw_rectangle(); 

            if (menuPage_idx == ABOUT_IDX) {
                display_about_page();
            } else {
                    if (menuPage_idx == IDX_RECOIL_CONTROL)
                        display_mod(center_x(sizeof(RECOIL_CONTROL) - 1, OLED_FONT_SMALL_WIDTH),
                                    RECOIL_CONTROL[0], recoilControl_on, Options[menuPage_idx]);

                    if (menuPage_idx == IDX_AIM_ASSIST)
                        display_mod(center_x(sizeof(AIM_ASSIST) - 1, OLED_FONT_SMALL_WIDTH),
                                    AIM_ASSIST[0], get_option_value(IDX_AIM_ASSIST), 1);

                    if (menuPage_idx == IDX_STICKY_AIM)
                        display_mod(center_x(sizeof(TRACKERMOD) - 1, OLED_FONT_SMALL_WIDTH),
                                    TRACKERMOD[0], stickyAim_on, Options[menuPage_idx]);

                    if (menuPage_idx == IDX_BUNNY_HOP)
                        display_mod(center_x(sizeof(BUNNY_HOP) - 1, OLED_FONT_SMALL_WIDTH),
                                    BUNNY_HOP[0], bunnyHop_on, Options[menuPage_idx]);

                    if (menuPage_idx == IDX_RUN_COMBO)  
                        display_mod(center_x(sizeof(RUN_COMBO) - 1, OLED_FONT_SMALL_WIDTH),
                                    RUN_COMBO[0], runCombo_on, Options[menuPage_idx]);                

                    if (menuPage_idx == IDX_PING_ENEMY)
                        display_mod(center_x(sizeof(PING) - 1, OLED_FONT_SMALL_WIDTH),
                                    PING[0], pingEnemy_on, Options[menuPage_idx]);

                    if (menuPage_idx == IDX_HOLD_BREATH)
                        display_mod(center_x(sizeof(HOLD) - 1, OLED_FONT_SMALL_WIDTH),
                                    HOLD[0], sniperApnea_on, Options[menuPage_idx]);

                    if (menuPage_idx == IDX_RAPIDFIRE)
                        display_mod(center_x(sizeof(RAPIDFIRE) - 1, OLED_FONT_SMALL_WIDTH),
                                    RAPIDFIRE[0], rapidFire_on, Options[menuPage_idx]);

                    // if (menuPage_idx == IDX_SLIDE_HOP)
                    //     display_mod(center_x(sizeof(SLIDE_HOP) - 1, OLED_FONT_SMALL_WIDTH),
                    //                 SLIDE_HOP[0], slideHop_on, Options[menuPage_idx]);
            }
            HOTHACK = FALSE;
        } 

        if (HOTHACKER543232327){
            cls_oled(0);
            HOTHACKE = FALSE;
            HOTHACKER543232327 = FALSE;
            display_black = FALSE;     // << don’t block the saver
            count_black = 0;
        }

        if(HOTHACKER54545454){
            block_all_inputs();

            if(MenuTimeOut){
                CheckIfBtnIsPressed();
            }

            if(event_release(BTN_MELEE)){
                HOTHACKER54545454 = FALSE;
                HOTHACKER54545    = FALSE;
                HOTHACKE          = TRUE;
                HOTHACK           = TRUE;
            }

            if(!get_ival(Aim) && event_press(PS4_DOWN)){            
                adjust_variable_idx ++;                 
                if(adjust_variable_idx > OptRange[ menuPage_idx ][ 1 ])  adjust_variable_idx = OptRange[ menuPage_idx ][ 1 ]; 
                HOTHACK = FALSE;      
                HOTHACKER54545 = TRUE;        
            }          
            if(!get_ival(Aim) && event_press(PS4_UP)){  
                adjust_variable_idx --;                                      
                if(adjust_variable_idx < OptRange[ menuPage_idx ][ 0 ]) adjust_variable_idx = OptRange[ menuPage_idx ][ 0 ];
                HOTHACK = FALSE;      
                HOTHACKER54545 = TRUE;        
            }     

            if(MenuTimeOut){
                CheckIfBtnIsPressed();
            }
        }

        if(get_ival(Aim) && event_press(BTN_MENU)){  
            HOTHACKE = TRUE;  
            SaverOn = FALSE;                     
            menuPage_idx  = 0;  
            HOTHACK = TRUE;      
            HOTHACKER54545 = FALSE;        
            MenuTimeOut  = menu_time_active;
        } 
        
                    
        if (HOTHACKE) {
            block_all_inputs();

            if (event_press(PS4_CIRCLE)) {
                HOTHACKE = FALSE;
                HOTHACKER54545454 = FALSE;
                combo_run(MESSAGE);
            }

            if (event_press(BTN_JUMP)) {
                // only enter editor when the current mod has editable values
                if (EditVal[menuPage_idx]) {
                    HOTHACKE = FALSE;
                    SaverOn = FALSE;        // keep saver off while editing values
                    adjust_variable_idx = OptRange[menuPage_idx][0];
                    HOTHACKER54545454 = TRUE;
                    HOTHACKER54545 = TRUE;
                } 
            }

            if (!get_ival(Aim) && event_press(PS4_DOWN)) {
                menuPage_idx = next_index(menuPage_idx);
            }
            if (!get_ival(Aim) && event_press(PS4_UP)) {
                menuPage_idx = prev_index(menuPage_idx);
            }


            if (!get_ival(Aim)) {
                if (event_press(PS4_RIGHT)) {
                    tmp_val = get_option_value(menuPage_idx);
                    tmp_val = f_go_back(tmp_val);
                    set_option_value(menuPage_idx, tmp_val);
                }
                if (event_press(PS4_LEFT)) {
                    tmp_val = get_option_value(menuPage_idx);
                    tmp_val = f_go_forward(tmp_val);
                    set_option_value(menuPage_idx, tmp_val);
                }
            }

            HOTHACK = TRUE;
            set_val(PS4_RIGHT, 0);
            set_val(PS4_LEFT, 0);
            set_val(PS4_UP, 0);
            set_val(PS4_DOWN, 0);

            if (MenuTimeOut) {
                CheckIfBtnIsPressed();
            }
        }

        if(aimSnap_enabled){
            CurrentRX = get_val(aim_x);
            CurrentRY = get_val(aim_y);

            CurrentRX = GetAIM_SNAP(CurrentRX, aimSnap_resolution);
            CurrentRY = GetAIM_SNAP(CurrentRY, aimSnap_resolution);

            set_val(aim_x, clamp(CurrentRX, -100, 100));
            set_val(aim_y, clamp(CurrentRY, -100, 100));
                
            }
                
        if( stickNoiseFilter_on ) { 
            RemoveStickNoise();
        }
        
        if (SaverOn){
            Timer += get_rtime();
            RunSaver();
        }
        if (Timer >= TimeoutLimit){
            SaverOn = FALSE;
            Timer = 0;
            cls_oled(0);
        }

        if (recoilControl_on) {
            if (get_val(Aim) && get_val(Fire) || get_ival(Fire)) {
                combo_run(EvilBot_Aimbot);
            }
        }
        
        if (aimAssist_mode == 1){
            if (get_ival(Aim) || get_ival(Fire) || (get_ival(Aim) && get_ival(Fire))){
                Soft_Aim();}
                
            if (get_val(Aim) && get_val(Fire)){
                combo_run(EvilBotV4);
                combo_run(aa_booster_combo);}
                }
                if (aimAssist_mode == 2)
            {
            if (get_ival(Aim) || get_ival(Fire) || (get_ival(Aim) && get_ival(Fire))){
                Soft_Aim();}
                
            if (get_val(Aim) || get_val(Fire)){
                combo_run(EvilBotV4);
                combo_run(aa_booster_combo);}
                }
        
        if (stickyAim_on) {
            if (get_ival(Aim) || get_ival(Fire) || (get_ival(Aim) && get_ival(Fire))) {
                CurRX = get_ival(aim_x);
                CurRY = get_ival(aim_y);

                if (get_ival(Aim) || (get_ival(Aim) && get_ival(Fire))) {
                    CurRX += get_polar_coordinate(stickyAim_size, sin_(TrackerAngle));
                    CurRY += get_polar_coordinate(stickyAim_size, cos_(TrackerAngle));
                }
                else {
                    CurRX += get_polar_coordinate(stickyAim_size, cos_(TrackerAngle));
                    CurRY += get_polar_coordinate(stickyAim_size, sin_(TrackerAngle));
                }

            TrackerAngle = (TrackerAngle + stickyAim_speed) % 360;
            set_val(aim_x, clamp(CurRX, -100, 100));
            set_val(aim_y, clamp(CurRY, -100, 100));
            }
        }
        
        // BUNNY_HOP
        if (bunnyHop_on) {
            // Start looping while hip-firing (Fire held, not ADS)
            if (get_val(Fire) && !get_val(Aim) && !combo_running(BUNNY_HOP)) {
                combo_run(BUNNY_HOP);
            }
            // Stop immediately if Fire released, ADS, or other interrupts
            if (!get_val(Fire) || get_val(Aim) ||
                event_press(BTN_TACTICAL) || event_press(BTN_LETHAL) || event_press(BTN_MELEE)) {
                combo_stop(BUNNY_HOP);
            }
        }

        // RUN COMBO: while Sprint held, run 2s -> slide -> hop -> repeat
        if (runCombo_on) {                                  
            if (get_lval(Sprint) && !get_val(Aim)) {
                // Don’t fight with other movement helpers while RUN COMBO is active
                combo_stop(BUNNY_HOP);
                combo_stop(SH_PRE_HOP);
                combo_stop(SH_DO_HOP);
                if (!combo_running(RUN_COMBO)) {
                    combo_run(RUN_COMBO);
                }
            } else {
                combo_stop(RUN_COMBO);
            }
        }
        
        if (killshotz_on) {
            if (PolarVIAssist) {
                if (get_ival(Aim) || get_ival(Fire) || (get_ival(Aim) && get_ival(Fire))) {

                    if (abs(get_val(aim_x)) <= polarAssist_radius && abs(get_val(aim_y)) <= polarAssist_radius) {
                        if (get_val(Fire)) {
                            KILLSHOTZVIAngle = PolarAngle;
                        } else {
                            KILLSHOTZVIAngle = PolarAngle;
                        }
                        set_polar(PS, VISpeed = (VISpeed + KILLSHOTZVIAngle) % 360, (polarAssist_radius * 328) + get_polar(PS,0));
                    }
                }
            } else {
                if (abs(get_val(aim_x)) < polarAssist_radius && abs(get_val(aim_y)) < polarAssist_radius) {
                    set_val(PS, 0);
                } else {
                    if (get_val(aim_x) >= polarAssist_radius) {
                        set_val(PS, 45);
                    } else if (get_val(aim_x) <= -polarAssist_radius) {
                        set_val(PS, 90);
                    } else if (get_val(aim_y) >= polarAssist_radius) {
                        set_val(PS, 0);
                    } else if (get_val(aim_y) <= -polarAssist_radius) {
                        set_val(PS, 90);
                    }
                }
            }
        }

        if(get_ival(Fire) && get_ptime(Fire) >= 300){
            combo_run(COMBO_PING_ENEMY);
        } else {
            combo_stop(COMBO_PING_ENEMY);
        }

        if(sniperApnea_on){
            if(get_val(Aim))
                set_val(Sprint, 100);
                        
            if(get_val(Aim) && get_lval(Sprint)) 
                set_val(Sprint, 0);  
        }
        
        // Rapid Fire: simple ON/OFF. “ON” = In Shooting (hip or ADS while Fire is held)
        if (rapidFire_on) {
            if (get_ival(PS4_LEFT) && event_press(Fire)) {
                HOTHACKER5454588 = !HOTHACKER5454588; // user’s arm/disarm hotkey remains
                display_MOD_status(HOTHACKER5454588, sizeof(RAPIDFIRE) - 1, RAPIDFIRE[0]);
                set_val(Fire, 0);
            }
        }

        if (rapidFire_on && HOTHACKER5454588) {
            if (get_ival(Fire)) {
                combo_run(EvilBot_auth_enabled);    // active whenever shooting
            } else {
                combo_stop(EvilBot_auth_enabled);
            }
        }

        // --- SLIDE HOP: arm on crouch release after a real slide ---
        if (event_press(Crouch)) {
            sh_tracking = 1;
            sh_hold_ms  = 0;
        }
        if (sh_tracking && get_val(Crouch)) {
            sh_hold_ms += get_rtime();
        }
        if (event_release(Crouch)) {
            sh_tracking = 0;
            if (slideHop_on                      // Slide Hop toggle
                && sh_hold_ms >= SH_MIN_SLIDE_MS        // it was a slide, not a tap
                && get_lval(Sprint)                     // still sprinting
                && !get_val(Aim)                        // not ADS
                && get_val(moveLY) <= FORWARD_THRESH) { // moving forward (DS4 forward is negative)
                sh_arming = 1;
                combo_run(SH_PRE_HOP);
            } else {
                sh_arming = 0;
            }
        }
        // cancel arming if conditions break before the jump fires
        if (sh_arming) {
            if (!get_lval(Sprint) || get_val(Aim) || get_val(Crouch)){
                combo_stop(SH_PRE_HOP);
                sh_arming = 0;
            }
        }

        if(time_to_clear_screen){               
            time_to_clear_screen -= get_rtime();
            if(time_to_clear_screen <= 0 ){     
                QT_MESSAGE_TIMEOUT();     
            }                              
        }            
    }  
    if (HOTHACKER545459999                // overlay enabled
        && !HOTHACKE                      // not in menu
        && !HOTHACKER54545454             // not in editor
        && !display_black                 // not in intro blackout
        && !SaverOn) {                    // saver is off during active use
    draw_venombyte_banner();
}
} // eof main

/* 
////////////// EDITOR BOUNDS: MIN/MAX PER VARIABLE /////////////////////////////
PURPOSE:
    FOR EACH EDITABLE VARIABLE, DEFINE LEGAL RANGE (INCLUSIVE). USED BY edit_val().
SAFETY:
    PREVENTS OUT-OF-RANGE INPUTS THAT COULD CAUSE STICK OVERFLOW OR STUTTER.
*/
const int16 ValRange[][] = {
    {  1,   90 },   //  0  aimSnap_resolution
    {  1,   50 },   //  1  input_deadzone
    {  1,  100 },   //  2  aimAssist_vmSpeed
    {  1,  100 },   //  3  aimAssist_width
    {  1,  100 },   //  4  aimAssist_vertical
    {  1,  100 },   //  5  aimAssist_size
    {  1,   50 },   //  6  aimAssist_time
    {  1,  100 },   //  7  stickyAim_size
    {  1,  100 },   //  8  stickyAim_speed
    { -100, 100 },  //  9  recoil_y_compensation  (Vertical Recoil; allow negative/positive)
    {  0,   10 },   // 10  bunnyHop_delayMultiplier
    {  0,  999 },   // 11  bunnyHop_timing_ms
    {  0,   99 },   // 12  aaBooster_frequency
    {  0, 2000 },   // 13  aaBooster_delay_ms
    {  1,  100 },   // 14  polarAssist_radius
    {  1,  100 },   // 15  param_slot_a
    {  1,  100 },   // 16  param_slot_b
    {  1, 2000 },   // 17  pingCooldown_ms
    {  1, 1000 },   // 18  rapidFire_on_ms
    {  1, 1000 },   // 19  rapidFire_off_ms
    {  1,  100 }    // 20  rapidFire_release_ms
};

/* 
////////////// VM TIMING CONTROLLER (INTERNAL SPEED PROFILES) ///////////////////
PURPOSE:
    SETS VIRTUAL MACHINE TIMING SCALES FOR SCRIPT EXECUTION CADENCE.
NOTE:
    CHANGING VM SPEED AFFECTS COMBO WAITS AND EVENT CADENCE—USE SPARINGLY.
*/
define VM_Default = 0;
function set_Virtual_Machine_Speed (f_speed){
    if     (f_speed == 0) vm_tctrl(-0);
    else if(f_speed == 1) vm_tctrl(-2);
    else if(f_speed == 2) vm_tctrl(-4);
    else if(f_speed == 3) vm_tctrl(-6);
    else if(f_speed == 4) vm_tctrl(-8);
    else if(f_speed == 5) vm_tctrl(-9);
}

/* 
////////////// EXIT UI COMBO: LEAVE MENU/EDITOR, RESTORE SAVER /////////////////
PURPOSE:
    GRACEFUL UI EXIT WITH SHORT DELAY, CLEAR OLED, RESET STATE, RE-ENABLE SAVER.
*/
int exit_wait = 1500;
combo EXIT {     
    wait(exit_wait);     
    cls_oled(0);    
    HOTHACKE = FALSE;  
    HOTHACKER54545454 = FALSE;    
    HOTHACKER54545  = FALSE;  
    SaverOn = TRUE;  // << turn screensaver back on after leaving menu/editor
    draw_venombyte_banner();         
}                             

/* 
////////////// UI COLOR CONSTANTS AND MENU STATE FLAGS //////////////////////////
PURPOSE:
    COLOR ENUMS FOR LED RGB AND GLOBAL FLAGS FOR MENU/TOGGLES.
*/
define ColorOFF  = 0;
define Blue      = 1;
define Red       = 2;
define Green     = 3;
define Pink      = 4;
define SkyBlue   = 5;
define Yellow    = 6;
define White     = 7;

int HOTHACK;        
int HOTHACKE;    
int HOTHACKER54545454;   
int HOTHACKER54545;   
int HOTHACKER545459999 = TRUE;   
int HOTHACKER54545DDD; 

int HOTHACKER5454588 = TRUE;
int HOTHACKER543232327 = TRUE;

/* 
////////////// RAPID FIRE ENGINE: RANDOMIZED BURSTS WHILE FIRING ///////////////
PURPOSE:
    WHEN ARMED, PULSES FIRE ON/OFF WITH SLIGHT RANDOMIZATION TO AVOID PATTERNING.
PARAMS:
    rapidFire_on_ms, rapidFire_off_ms ARE READ EACH CYCLE; RELEASE MSPACING TOO.
*/
combo EvilBot_auth_enabled { 
    set_val(Fire, 100);
    wait(random(rapidFire_on_ms, rapidFire_on_ms * 2));
    set_val(Fire, 0);
    wait(random(rapidFire_off_ms, rapidFire_off_ms * 2)); 
}

/* 
////////////// OLED SPLASH CLEAR AFTER TIMEOUT //////////////////////////////////
PURPOSE:
    CLEARS INTRO/SPLASH FLAGS AND OLED AFTER A SHORT DURATION.
*/
function QT_MESSAGE_TIMEOUT (){     
	cls_oled(0);   
	HOTHACKER543232327  = FALSE;           
}

/* 
////////////// SCREENSAVER PARTICLE STEP (RANDOM PIXELS / BLINK) ///////////////
PURPOSE:
    ANIMATED SAVER; TOGGLES PIXELS AND BLINKS BRAND/VER TEXT AT INTERVALS.
PERF:
    LIGHTWEIGHT—USES get_rtime() TO TIME BLINKS.
*/
combo NotoriouscriptzVIP {
    NotoriouscriptzVIP_x = random(1,128);
    NotoriouscriptzVIP_y = random(1,64);
}

/* 
////////////// RECOIL CONTROL: APPLY VERTICAL COMPENSATION //////////////////////
PURPOSE:
    ADDS recoil_y_compensation TO AIM_Y WHILE SHOOTING TO COUNTER VERTICAL KICK.
SAFETY:
    CLAMPS TO [-100, 100] TO AVOID STICK SATURATION.
*/
combo EvilBot_Aimbot {
    // Y (vertical) anti-recoil
    anti_recoil_y = get_ival(aim_y) + recoil_y_compensation;
    if (anti_recoil_y > 100) anti_recoil_y = 100;
    if (anti_recoil_y < -100) anti_recoil_y = -100;
    set_val(aim_y, anti_recoil_y);
}

/* 
////////////// AIM ASSIST CORE: STICKY OSCILLATION PATTERN /////////////////////
PURPOSE:
    CREATES LEFT/RIGHT MICRO-OFFSETS AROUND CENTER TO STAY IN THE AA “BUBBLE”.
PARAMS:
    aimAssist_size (AMPLITUDE) AND aimAssist_time (DWELL); USES offset_sticky_aa().
*/
combo EvilBotV4 {
    offset_sticky_aa(moveLX, aimAssist_size * 10);
    wait(aimAssist_time * 10);
    offset_sticky_aa(moveLX, inv(aimAssist_size * 10));
    wait(aimAssist_time * 10);
}

/* 
////////////// AIM ASSIST BOOSTER: MICRO-JITTERS FOR ENTRY //////////////////////
PURPOSE:
    ADDS SMALL RANDOMIZED JITTERS (X/Y) TO HELP “GRAB” TARGETS WHEN NEAR CENTER.
CAUTION:
    TOO LARGE WILL FEEL SHAKY; aimAssist_time AND size GOVERN INTENSITY.
*/
combo aa_booster_combo{
    X = random(inv(aimAssist_size), aimAssist_size);
    offset_sticky_aa(moveLX, 27);
    offset_sticky_aa(moveLY, X);
    wait(aimAssist_time * 10);
    offset_sticky_aa(moveLX, inv(25));
    offset_sticky_aa(moveLY, X);
    wait(aimAssist_time * 8);
    offset_sticky_aa(moveLY, X);
    offset_sticky_aa(moveLX, 25);
    wait(aimAssist_time * 10);
    offset_sticky_aa(moveLX, inv(27));
    offset_sticky_aa(moveLY, X);
    wait(aimAssist_time * 8);
}

/* 
////////////// BUNNY HOP: CROUCH TAP + DOUBLE JUMP + LOOP //////////////////////
PURPOSE:
    HIP-FIRE MOBILITY TOOL. CROUCH PULSE, THEN DOUBLE-JUMP WITH TIMERS, THEN LOOP.
GUARDS:
    main() STARTS WHEN FIRE HELD AND !ADS; STOPS ON RELEASE/ADS/INTERRUPTS.
TUNING:
    bunnyHop_delayMultiplier & bunnyHop_timing_ms CONTROL PACE AND CADENCE.
*/
combo BUNNY_HOP {
    // optional wind-up
    wait(bunnyHop_delayMultiplier * 250);

    // crouch tap
    set_val(Crouch, 100);
    wait(bunnyHop_timing_ms);
    set_val(Crouch, 0);
    wait(bunnyHop_timing_ms);

    // single jump
    // set_val(BTN_JUMP, 100);
    // wait(bunnyHop_timing_ms / 2);
    // set_val(BTN_JUMP, 0);

    // double jump
    set_val(BTN_JUMP, 100);
    wait(bunnyHop_timing_ms / 2);
    set_val(BTN_JUMP, 0);
    wait(bunnyHop_timing_ms / 3);
    set_val(BTN_JUMP, 100);
    wait(bunnyHop_timing_ms / 2);
    set_val(BTN_JUMP, 0);

    // small cooldown between jumps
    wait(bunnyHop_timing_ms);

    // loop again; main() will stop it when conditions fail
    combo_restart(BUNNY_HOP);
}

/* 
////////////// PING ENEMY: BURST TAPS WITH COOLDOWN ////////////////////////////
PURPOSE:
    AUTOMATES PING BUTTON WHILE FIRING (AFTER HOLD THRESHOLD) WITH COOLDOWN.
PARAMS:
    pingCooldown_ms DEFINES GAP BETWEEN BURSTS.
*/
combo COMBO_PING_ENEMY {
    set_val(Ping,100);
    wait(20);
    set_val(Ping,0);
    wait(20);
    set_val(Ping,100);
    wait(20);
    set_val(Ping,0); 
    wait(pingCooldown_ms); 
}

/* 
////////////// SLIDE HOP CONSTANTS AND STATE ///////////////////////////////////
PURPOSE:
    TIMINGS AND STATE FOR “JUMP AS SLIDE ENDS” MOVEMENT TECHNIQUE.
NOTES:
    sh_tracking/hold_ms DETECT A REAL SLIDE VS QUICK TAP; FORWARD_THRESH REQUIRES
    FORWARD MOTION TO AVOID ACCIDENTAL TRIGGERS.
*/
define SH_MIN_SLIDE_MS      = 180;  // hold crouch at least this long to count as a slide
define SH_DEBOUNCE_MS       = 60;   // short delay after release so you're truly "standing up"
define SH_STAND_TAP_MS      = 55;   // first X tap: pop from crouch to stand
define SH_BETWEEN_TAPS_MS   = 45;   // gap between the two taps
define SH_HOP_TAP_MS        = 90;   // second X tap: actual jump
define FORWARD_THRESH       = -20;  // LY must be forward (on DS4, forward ≈ negative)

int sh_tracking   = 0;  // tracking slide-hold time
int sh_hold_ms    = 0;  // how long crouch has been held
int sh_arming     = 0;  // armed to fire hop after debounce

/* 
////////////// SLIDE HOP: PRE-HOP DEBOUNCE //////////////////////////////////////
PURPOSE:
    SHORT WAIT AFTER CROUCH RELEASE TO ENSURE WE ARE STANDING BEFORE JUMP SEQUENCE.
*/
combo SH_PRE_HOP {
    wait(SH_DEBOUNCE_MS);
    combo_run(SH_DO_HOP);
}

/* 
////////////// SLIDE HOP: STAND TAP THEN JUMP TAP //////////////////////////////
PURPOSE:
    TWO TAP SEQUENCE ON JUMP BUTTON: FIRST ENSURES UPRIGHT, SECOND EXECUTES HOP.
*/
combo SH_DO_HOP {
    // 1) quick X to ensure we’re upright
    set_val(BTN_JUMP, 100);
    wait(SH_STAND_TAP_MS);
    set_val(BTN_JUMP, 0);

    // small gap, then…
    wait(SH_BETWEEN_TAPS_MS);

    // 2) proper jump
    set_val(BTN_JUMP, 100);
    wait(SH_HOP_TAP_MS);
    set_val(BTN_JUMP, 0);

    sh_arming = 0;
}

/* 
////////////// OLED TOAST: MOD STATUS CENTERED THEN AUTO-CLEAR /////////////////
PURPOSE:
    RENDERS A CENTERED STATUS CARD (MOD NAME + ON/OFF), THEN AUTO-CLEARS.
*/
int time_to_clear_screen;
function display_MOD_status(f_val,f_size,f_label){  
    if(!HOTHACKE && !HOTHACKER54545454){                                           
        cls_oled(0);  
        print(f_size, 3, OLED_FONT_MEDIUM ,OLED_WHITE, f_label);   
        if( f_val ){
            print(center_x(sizeof(ON)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_LARGE,OLED_WHITE, ON[0]);
        }
        else{
            print(center_x(sizeof(OFF)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_LARGE,OLED_WHITE, OFF[0]);
        }    
        time_to_clear_screen = 1500; 
    } 
}

/* 
////////////// SCREENSAVER DRIVER: BRAND/VER BLINK + PARTICLES /////////////////
PURPOSE:
    SCHEDULER FOR SAVER PIXEL STEPS AND TEXT BLINKS. TOGGLES BETWEEN FRAMES.
*/
function RunSaver() {
    if (SaverOn) {
        pixel_oled(NotoriouscriptzVIP_x, NotoriouscriptzVIP_y, NotoriouscriptzVIP_c);
        combo_run(NotoriouscriptzVIP);
        NotoriouscriptzVIP_t += get_rtime();

        if (NotoriouscriptzVIP_t >= 500) {
            draw_venombyte_banner();
            NotoriouscriptzVIP_t = 0;
        }
    }
}

/* 
////////////// STRING UTIL: COUNT CHARS AT OFFSET ///////////////////////////////
PURPOSE:
    MEASURE STRING LENGTH FROM A GIVEN OFFSET FOR CENTERING CALCULATIONS.
*/
int stringLength;
function getStringLength(offset) {
    stringLength = 0; do {
        offset++;stringLength++;
    } while (duint8(offset));
    return stringLength;
}

/* 
////////////// POLAR HELPERS: CLAMP RADIUS AND SCALE BY TRIG ////////////////////
PURPOSE:
    LIMITS RADIUS TO SAFE RANGE AND SCALES USING PRECOMPUTED SIN/COS COEFS.
*/
function get_polar_coordinate(Radius, coef) {
	if (Radius > 32) {
		Radius = 32;
	}
	else if (Radius > 20) {
		Radius = 20;
	}

	return (Radius * coef) / 1000;
}

/* 
////////////// OLED CENTERING BY FONT METRICS ///////////////////////////////////
PURPOSE:
    RETURNS START X SO TEXT WITH N CHARACTERS IS HORIZONTALLY CENTERED.
*/
function centerPosition(f_chars,f_font) {
    return (OLED_WIDTH / 2) - ((f_chars * f_font) / 2);
}

/* 
////////////// STICK OFFSET: BOUNDED ADDITIVE MOVE WITH GAIN ////////////////////
PURPOSE:
    APPLIES A DELTA TO A STICK AXIS WITH AUTO-GAIN SO MOVES NEAR EDGE ARE SMALLER.
SAFETY:
    CLAMPS RESULT TO [-100, 100].
*/
function offset_sticky_aa(Stick,Value) {
    set_val(Stick, clamp(Value * (100 - abs(get_ival(Stick))) / 100 + get_ival(Stick), -100, 100));return;
}

/* 
////////////// SOFT AIM ENGINE: CIRC/ORTH PATTERN WITH VM/WIDTH /////////////////
PURPOSE:
    CORE “SOFT” AIM-ASSIST MOTION. BUILDS A CIRCULAR/ORTHOGONAL DRIFT PATTERN
    AROUND CURRENT INPUT TO MAINTAIN STICKINESS WITHOUT OVERPOWERING INPUT.
PARAMS:
    aimAssist_vmSpeed (PHASE SPEED), aimAssist_width (AMPLITUDE), input_deadzone.
*/
function Soft_Aim() {
    lx_aim = get_ival(aim_x);
    ly_aim = get_ival(aim_y);
    input_mag = isqrt((lx_aim * lx_aim) + (ly_aim * ly_aim));
    
    if (input_mag < input_deadzone) {
        lx_aim = 0;
        ly_aim = 0;
    }
    
    if (!first_aim) {
        first_aim = 1;
        aim_speed = atan2_16bits(ly_aim, lx_aim);
    } else {
        aim_speed = (aim_speed + aimAssist_vmSpeed) % 360;
    }
    
    aim_width = aimAssist_width; 
    
    if (aim_width > 32) {
        aim_width = 32;
    }
    else if (aim_width < inv(31)) {
        aim_width = inv(31);
    }
    
    if (toggle_active_aiming) {
        lx_aim = lx_aim + ((aim_width * cos_(aim_speed)) / 1000);
        ly_aim = ly_aim + ((aim_width * sin_(aim_speed)) / 1000);
    }
    else {
        lx_aim = lx_aim + ((aim_width * sin_(aim_speed)) / 1000);
        ly_aim = ly_aim + ((aim_width * cos_(aim_speed)) / 1000);
    }
    
    active_aiming_counter++;
    
    if (active_aiming == active_aiming_counter) {
        active_aiming_counter = 0;
        toggle_active_aiming = toggle_active_aiming ^ 1;
    }
    
    lx_aim = clamp(lx_aim, -100, 100);
    ly_aim = clamp(ly_aim, -100, 100);
    set_val(aim_x, lx_aim);
    set_val(aim_y, ly_aim);
}	

/* 
////////////// FAST INTEGER ATAN2 FOR AIM ANGLES ////////////////////////////////
PURPOSE:
    ANGLE COMPUTATION FOR AA PATTERN WITHOUT FLOATING-POINT COST.
RETURN:
    0..359 DEGREES (INTEGER). USED BY Soft_Aim() FOR PHASE INCREMENTING.
*/
function atan2_16bits(_y, _x) {
    if (_y >= 0) {
        if (_x >= 0) {
            if (_x > _y) {
                _angle = ((_y * 300) / _x);
            } else {
                if (_y == 0) {
                    _angle = 0;
                } else {
                    _angle = 540 - ((_x * 300) / _y);
                }
            }
        } else {
            if (_x >= inv(_y)) {
                _angle = 540 - ((_x * 300) / _y);
            } else {
                _angle = 1080 + ((_y * 300) / _x);
            }
        }
    } else {
        if (_x < 0) {
            if (_x < _y) {
                _angle = ((_y * 300) / _x) - 1080;
            } else {
                _angle = ((inv(_x) * 300) / _y) - 540;
            }
        } else {
            if (inv(_x) >= _y) {
                _angle = ((inv(_x) * 300) / _y) - 540;
            } else {
                _angle = ((_y * 300) / _x);
            }
        }
    }

    return (_angle / 6);
}

/* 
////////////// FAST SIN LOOKUP (QUADRANT SYMMETRY) //////////////////////////////
PURPOSE:
    APPROXIMATE SIN USING A LOOKUP TABLE AND QUADRANT MIRRORING.
RANGE:
    RETURNS SCALED INT (0..±1000). MATCHES Hacked[] SCALE.
*/
function sin_(_angle) {
	if (_angle <= 90) {
		return Hacked[_angle];
	}
	else if (_angle <= 180) {
		return Hacked[180 - _angle];
	}
	else if (_angle <= 270) {
		return inv(Hacked[_angle - 180]);
	}
	else {
		return inv(Hacked[360 - _angle]);
	}

	return 0;
}	

/* 
////////////// AIM SNAP: QUANTIZE AXIS INTO GRID STEPS //////////////////////////
PURPOSE:
    SNAPS STICK AXIS TO INCREMENTS (Resolution) TO STABILIZE FINE AIM.
EFFECT:
    REDUCES MICRO NOISE AND CAN “CLICK” INTO ENEMY HITBOXES MORE RELIABLY.
*/
function GetAIM_SNAP(Axis, Resolution) {
    if (Axis >= 0) {
        ReT = (Axis % Resolution);
        if (ReT >= (Resolution / 2)) {
            Axis = Axis + (Resolution - ReT);
        } else {
            Axis -= ReT;
        }
    } else {
        ReT = (Axis % Resolution);
        if (abs(ReT) >= (Resolution / 2)) {
            Axis = Axis - (Resolution + ReT);
        } else {
            Axis += abs(ReT);
        }
    }
    return Axis;
}

/* 
////////////// FAST COS LOOKUP (QUADRANT SYMMETRY) //////////////////////////////
PURPOSE:
    APPROXIMATE COS USING THE SAME TABLE AS SIN WITH OFFSET RULES.
*/
function cos_(_angle) {
	if (_angle <= 90) {
		return Hacked[90 - _angle];
	}
	else if (_angle <= 180) {
		return inv(Hacked[_angle - 90]);
	}
	else if (_angle <= 270) {
		return inv(Hacked[270 - _angle]);
	}
	else {
		return Hacked[_angle - 270];
	}
	return 0;
}

/* 
////////////// TRIG LUT (SCALED 0..1000) FOR SIN/COS ///////////////////////////
PURPOSE:
    PRECOMPUTED SINE SAMPLES TO AVOID RUNTIME COSTS. USED BY sin_/cos_.
NOTE:
    DO NOT EXCEED INDEX 0..90 IN RAW LOOKUPS; HIGHER ANGLES ARE MIRRORED.
*/
const int16 Hacked[] = {
    0, 8, 17, 23, 34, 41, 52, 59, 63, 69,
    75, 81, 87, 90, 104, 121, 139, 156, 173, 190,
    207, 224, 241, 258, 275, 292, 309, 325, 342, 358,
    374, 390, 406, 422, 438, 453, 469, 484, 500, 515,
    529, 544, 559, 573, 587, 601, 615, 629, 642, 656,
    669, 682, 694, 707, 719, 731, 743, 754, 766, 777,
    788, 798, 809, 819, 829, 838, 848, 857, 866, 874,
    882, 891, 898, 906, 913, 920, 927, 933, 939, 945,
    951, 956, 961, 965, 970, 974, 978, 981, 984, 987,
    990, 992, 994, 996, 997, 998, 999, 1000, 1007, 1015,
    1022, 1029, 1035, 1041, 1047, 1052, 1057, 1061, 1065, 1069,
    1072, 1075, 1078, 1080, 1083, 1085, 1087, 1089, 1090, 1092,
    1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100
};

/* 
////////////// STICK NOISE FILTER: APPLY DEADZONES //////////////////////////////
PURPOSE:
    ZEROES TINY STICK INPUTS WITHIN input_deadzone FOR BOTH MOVE AND AIM STICKS.
IMPACT:
    PREVENTS DRIFT FROM TRIGGERING MODS OR CAUSING MICRO-SHAKE.
*/
function RemoveStickNoise() {
    if(isqrt(pow(abs(get_ival(moveLX)),2) + pow(abs(get_ival(moveLY)),2)) <= input_deadzone) {
        set_val(moveLX,0); set_val(moveLY,0);
    }
    if(isqrt(pow(abs(get_ival(aim_x)),2) + pow(abs(get_ival(aim_y)),2)) <= input_deadzone) {
        set_val(aim_x,0); set_val(aim_y,0);
    }
}

/* 
////////////// FONT METRICS INDICES (WIDTH/HEIGHT/MAXCHARS) /////////////////////
PURPOSE:
    INDEXES FOR FONT WIDTH/HEIGHT/CELL COUNT USED BY CENTERING MATH.
*/
define FONT_STATS_INDEX_WIDTH    = 0; 
define FONT_STATS_INDEX_HEIGHT   = 1; 
define FONT_STATS_INDEX_MAXCHARS = 2; 

/* 
////////////// OLED CENTERING USING FONT STATS //////////////////////////////////
PURPOSE:
    RETURNS LEFT X OFFSET FOR A STRING WITH N CHARS AT A GIVEN FONT SIZE.
*/
function horizontal_center_offset(number_characters, font_size) { 
    return (128 - number_characters * FONT_STATS[font_size][FONT_STATS_INDEX_WIDTH]) / 2;
}             

/* 
////////////// EXIT MESSAGE STRINGS (CURRENTLY EMPTY) ///////////////////////////
PURPOSE:
    PLACEHOLDERS FOR A “SAVED / EXITING” TOAST IF YOU DECIDE TO SHOW IT.
*/
const string EXIT_TXT1 = "";  
const string EXIT_TXT2 = ""; 

/* 
////////////// PERSIST ALL TOGGLES/VALUES TO SPVARS THEN EXIT ///////////////////
PURPOSE:
    WRITES EVERY TOGGLE/SETTING TO SPVAR KEYS; CALLS EXIT TO LEAVE UI CLEANLY.
ROBUSTNESS:
    ENSURES STICKY AIM PRESET STORED WHEN ON; LOCKS RF TIMINGS TO SAFE DEFAULTS.
*/
function save_toggles () {                    
    set_pvar(SPVAR_1,1);                        // AIM SNAP locked ON 
    set_pvar(SPVAR_2,stickNoiseFilter_on);
    set_pvar(SPVAR_3,aimAssist_mode);
    set_pvar(SPVAR_5,recoilControl_on);
    set_pvar(SPVAR_16,bunnyHop_on);
    set_pvar(SPVAR_19,0);
    set_pvar(SPVAR_26, 1);                      // always persist ON
    set_pvar(SPVAR_29,0);                      // always persist OFF
    set_pvar(SPVAR_31,sniperApnea_on);
    set_pvar(SPVAR_32,rapidFire_on);
    set_pvar(SPVAR_35,rapidFire_speedProfile);
    set_pvar(SPVAR_6,3);                        // AIM SNAP step locked to 3 
    set_pvar(SPVAR_7,input_deadzone);
    set_pvar(SPVAR_8,aimAssist_vmSpeed);
    set_pvar(SPVAR_9,aimAssist_width);
    set_pvar(SPVAR_10,aimAssist_vertical);
    set_pvar(SPVAR_11,aimAssist_size);
    set_pvar(SPVAR_12,aimAssist_time);
    set_pvar(SPVAR_15,recoil_y_compensation);
    set_pvar(SPVAR_17,bunnyHop_delayMultiplier);
    set_pvar(SPVAR_18,bunnyHop_timing_ms);
    set_pvar(SPVAR_20,aaBooster_frequency);
    set_pvar(SPVAR_21,aaBooster_delay_ms);
    set_pvar(SPVAR_23,userHotkeyCode);
    set_pvar(SPVAR_24,param_slot_a);
    set_pvar(SPVAR_25,param_slot_b);
    set_pvar(SPVAR_27,polarAssist_radius);
    set_pvar(SPVAR_30,pingCooldown_ms);
    set_pvar(SPVAR_33,rapidFire_on_ms); 
    set_pvar(SPVAR_34,rapidFire_off_ms);                       // RAPID FIRE: VM speed locked to 7
    set_pvar(SPVAR_37, rapidFire_release_ms);                  // RAPID FIRE: Delay locked to 22ms
    set_pvar(SPVAR_38, runCombo_on);
    // set_pvar(SPVAR_29, slideHop_on);             // persist SLIDE HOP ON/OFF
    // TRACKERMOD: persist toggle; if ON also persist preset
    set_pvar(SPVAR_4, stickyAim_on);
    if (stickyAim_on) {
        set_pvar(SPVAR_13, 18);
        set_pvar(SPVAR_14, 90);
    }
    combo_run(EXIT);    
}

// RUN COMBO: run 2s -> slide -> hop -> small recovery -> repeat while Sprint is held
// Uses crouch timing similar to SH_MIN_SLIDE_MS so it registers as a true slide
define RC_RUN_MS        = 2000; // how long to keep running before slide
define RC_SLIDE_MS      = 220;  // how long to hold crouch for slide
define RC_STAND_MS      = 60;   // brief stand-up debounce after slide
define RC_JUMP_MS       = 90;   // jump tap duration
define RC_RECOVER_MS    = 120;  // cooldown before next cycle

combo RUN_COMBO {
    // Keep running forward (player controls direction)—just time gate
    wait(RC_RUN_MS);

    // Slide
    set_val(Crouch, 100);
    wait(RC_SLIDE_MS);
    set_val(Crouch, 0);

    // Stand debounce
    wait(RC_STAND_MS);

    // Hop
    set_val(BTN_JUMP, 100);
    wait(RC_JUMP_MS);
    set_val(BTN_JUMP, 0);

    // small recovery before next slide+hop cycle
    wait(RC_RECOVER_MS);

    // Loop. main() stops this if Sprint released or ADS engaged.
    combo_restart(RUN_COMBO);
}

/* 
////////////// SAVE-AND-EXIT PRINT + SCHEDULE EXIT COMBO ////////////////////////
PURPOSE:
    OPTIONAL TOAST RENDER + QUICK EXIT; RELIES ON EXIT COMBO TO CLEAN STATE.
*/
combo MESSAGE {       
    wait(20);         
    save_toggles ();  
    cls_oled(0);      
    print(horizontal_center_offset(sizeof(EXIT_TXT1), OLED_FONT_MEDIUM ), 2,  OLED_FONT_MEDIUM, OLED_WHITE, EXIT_TXT1[0]); 
    print(horizontal_center_offset(sizeof(EXIT_TXT2), OLED_FONT_MEDIUM ), 23, OLED_FONT_MEDIUM, OLED_WHITE, EXIT_TXT2[0]);
    exit_wait = 200;     
}  

/* 
////////////// FONT METRICS TABLE (SMALL / MEDIUM / LARGE) //////////////////////
PURPOSE:
    WIDTH/HEIGHT/MAXCHARS FOR THREE OLED FONTS. USED BY CENTERING HELPERS.
*/        
const uint8 FONT_STATS[][] = {  
    {  7, 10, 18 },   
    { 11, 18, 11 }, 
    { 16, 26,  7 }     
};                              

/* 
////////////// EDITOR HEADER LINE + VALUE RENDER ////////////////////////////////
PURPOSE:
    PRINTS THE CURRENT FIELD LABEL AND ITS NUMERIC VALUE (BIG) IN THE EDITOR.
*/                                
function HOTHACKER54545(  f_val) {
    print(2, 2, OLED_FONT_SMALL, OLED_WHITE, EditVarStr[adjust_variable_idx]); 
    number_to_string(f_val, find_digits(f_val));     
} 

/* 
////////////// MENU OPTION CYCLE FORWARD WITH WRAP //////////////////////////////
PURPOSE:
    INCREMENT CURRENT PAGE’S OPTION VALUE; WRAP AT UPPER BOUND.
*/
function f_go_forward (f_variable) {
    f_variable       +=1;   
    if(f_variable  > Min_Max_Options[menuPage_idx][1] )f_variable  = Min_Max_Options[menuPage_idx][0]; 

    return f_variable;
}

/* 
////////////// MENU OPTION CYCLE BACKWARD WITH WRAP /////////////////////////////
PURPOSE:
    DECREMENT CURRENT PAGE’S OPTION VALUE; WRAP AT LOWER BOUND.
*/
function f_go_back (f_variable) {
    f_variable       -=1;   
    if(f_variable  < Min_Max_Options[menuPage_idx][0] )f_variable  = Min_Max_Options[menuPage_idx][1]; 
    return f_variable;
}

/* 
////////////// PRINT BIG NUMBER CENTERED TO OLED ////////////////////////////////
PURPOSE:
    RENDERS A LARGE, CENTERED INTEGER USING PUTS/PUTC PRIMITIVES.
*/
int ssss;                            
int c_c_c,c_val;   
function number_to_string(f_val,f_digits) {                  

    ssss = 1;  c_val = 10000;
    if(f_val < 0) {
        putc_oled(ssss,45);         
        ssss += 1;                                      
        f_val = abs(f_val);                          
    }                                                 

    for(c_c_c = 5; c_c_c >= 1; c_c_c--) {                                                 
        if(f_digits >= c_c_c)                             
        {                                             
            putc_oled(ssss,ASCII_NUM[f_val / c_val]);    
            f_val = f_val % c_val;                    
            ssss +=  1;                                  
            if(c_c_c == 4)                               
            {                                         
                putc_oled(ssss,44);          
                ssss += 1;                               
            }                                        
        }                                             
        c_val /= 10;                                  
    }                                                
    puts_oled(center_x(ssss - 1,OLED_FONT_MEDIUM_WIDTH),27,OLED_FONT_MEDIUM,ssss - 1,OLED_WHITE); 
} 

/* 
////////////// PRINT SMALL NUMBER AT POSITION ///////////////////////////////////
PURPOSE:
    UTILITY FOR SMALL, POSITIONED NUMBERS (MIN/MAX IN EDITOR).
*/
int n_str_;                 
function print_number(f_val,f_digits ,print_s_x , print_s_y , f_font) { 
    n_str_ = 1;  c_val = 10000;     

    if(f_val < 0) {                                                 
            putc_oled(n_str_,45);     
            n_str_ += 1;                                 
            f_val = abs(f_val);                          
        }                                                 

    for(c_c_c = 5; c_c_c >= 1; c_c_c--) {                                                 
        if(f_digits >= c_c_c)                             
        {                                              
            putc_oled(n_str_,ASCII_NUM[f_val / c_val]);
            f_val = f_val % c_val;                    
            n_str_ +=  1;                             
        }                                             
        c_val /= 10;                                  
    }                                                 
    puts_oled(print_s_x,print_s_y,f_font,n_str_ - 1,OLED_WHITE); 
}                                       

/* 
////////////// EDIT WIDGET: ARROWS, MIN/MAX, STEP/HOLD //////////////////////////
PURPOSE:
    FULL NUMERIC EDIT CONTROL—DRAWS ARROWS, RESPECTS ValRange BOUNDS, AND
    SUPPORTS SINGLE-STEP AND FAST-STEP (UP/DOWN) INCREMENTS WHILE AIM HELD.
*/
int f_min, f_max;
define Y_Arrow = 36;
function edit_val( f_val) {   
    line_oled(1,14,127,14,1,1);           // keep only the top divider
    putc_oled(1,LEFT_arrow);
    putc_oled(1,RIGHT_arrow);
    putc_oled(1,UP_arrow);
    putc_oled(1,DOWN_arrow);

    f_min = ValRange[adjust_variable_idx][0];                          
    f_max = ValRange[adjust_variable_idx][1];  

    print_number(f_min ,find_digits(f_min) ,4 , 20 , OLED_FONT_SMALL); 
                                            
    print_number(f_max ,find_digits(f_max) ,97 , 20 , OLED_FONT_SMALL);
    
    if(get_ival(Aim)){
        if(press_(PS4_RIGHT)){
            f_val ++;
            if(f_val > f_max ) f_val = f_max;
            HOTHACKER54545 = TRUE;
        }
        if(press_(PS4_LEFT)){
            f_val --;
            if(f_val < f_min ) f_val = f_min;
            HOTHACKER54545 = TRUE;

        }                                     
        if(press_(PS4_UP)){               
            f_val +=10;                         
            if(f_val > f_max ) f_val = f_max;   
            HOTHACKER54545 = TRUE;                
            
        }                                     
        if(press_(PS4_DOWN)){             
            f_val -=10;                         
            if(f_val < f_min ) f_val = f_min;   
            HOTHACKER54545 = TRUE;                
            
        }                                     
    }                                      
    return f_val;                        
}    

/* 
////////////// KEY REPEAT: TAP OR HELD-REPEAT INPUT /////////////////////////////
PURPOSE:
    RETURNS TRUE ON FIRST TAP OR PERIODICALLY WHEN A BUTTON IS HELD.
*/
function press_(f_btn) {

	return event_press(f_btn) || get_ival(f_btn) && get_ptime(f_btn) > 250 
	       && get_ptime(f_btn) % (get_rtime() * 8) == 0;
} 

/* 
////////////// UTILITY: DIGIT COUNT OF POSITIVE INTEGER /////////////////////////
PURPOSE:
    CALCULATE HOW MANY CHARACTERS ARE NEEDED TO DRAW A GIVEN NUMBER.
*/
function find_digits(f_num) {                                   
    f_num = abs(f_num);                               
    if(f_num / 10000 > 0) return 5;                   
    if(f_num /  1000 > 0) return 4;                   
    if(f_num /   100 > 0) return 3;                   
    if(f_num /    10 > 0) return 2;                   
    return 1;                  
}                                                     

/* 
////////////// OLED CENTER X BY CHARACTER COUNT /////////////////////////////////
PURPOSE:
    CENTER TEXT HORIZONTALLY USING FONT CELL WIDTH AND CHARACTER COUNT.
*/
function center_x(f_chars,f_font) {           
    return (OLED_WIDTH / 2) - ((f_chars * f_font) / 2); 
}                                                      

/* 
////////////// UI FRAME: BORDER AND SEPARATORS //////////////////////////////////
PURPOSE:
    DRAWS PAGE BORDER AND TOP/BOTTOM DIVIDER LINES FOR CONSISTENT LAYOUT.
*/
function draw_rectangle() {
    rect_oled(0, 0,OLED_WIDTH,64,FALSE,1); 
    line_oled(1,14,127,14,1,1); 
    line_oled(1,48,127,48,1,1); 
}

/* 
////////////// OPTION LABELS: SHOT MODES AND VM SPEEDS //////////////////////////
PURPOSE:
    HUMAN-READABLE NAMES FOR OPTION FAMILIES 31 (SHOT MODES) AND 50 (VM SPEEDS).
*/
define ShotModOptions = 31;
define FireModOptions =  9;
const string ModOption_31_0 = "OFF"; 
const string ModOption_31_1 = "Single Shot"; 
const string ModOption_31_2 = "Aim + Shot"; 
const string ModOption_31_3 = "Just Pointed"; 
const string ModOption_31_4 = "In Shooting";
const string ModOption_50_0 = "Default"; 
const string ModOption_50_1 = "8 ms"; 
const string ModOption_50_2 = "6 ms"; 
const string ModOption_50_3 = "4 ms"; 
const string ModOption_50_4 = "2 ms"; 
const string ModOption_50_5 = "1 ms";

/* 
////////////// GLYPH CODES & LAYOUT CONSTANTS FOR OLED //////////////////////////
PURPOSE:
    SPECIAL CHARACTER CODES (ARROWS, CROSS/Y/TEXT) AND ROW/LAYOUT CONSTANTS.
*/
define UP_arrow         = 131; 
define DOWN_arrow       = 132; 
define LEFT_arrow       = 133; 
define RIGHT_arrow      = 134; 
define TRIANGLE_txt     = 130; 
define Y_txt            = 89; 
define CROSS_txt        = 127; 
define A_txt            = 65;
define SINGLE           = 21;
define ROW_1            = 21;
define ROW_2            = 33;
const string MOD_LABEL  ="";
const string SLOT_LABEL ="";
int slot_numb;

/* 
////////////// OLED PAGE RENDERER: MOD TITLE / PAGE / SLOT / OPTION ////////////
PURPOSE:
    COMPOSES THE PAGE: TITLE LINE, PAGE NO., SLOT NO., AND CURRENT OPTION TEXT.
INPUTS:
    mod_name, f_toggle (NUMERIC VALUE/STATE), f_option (OPTION FAMILY ID).
*/
function display_mod(f_string, mod_name, f_toggle, f_option) {   
    print(f_string, 2, OLED_FONT_SMALL, OLED_WHITE, mod_name);  // was OLED_BLACK
        
    print(2, 38, OLED_FONT_SMALL, OLED_WHITE, MOD_LABEL[0]);     // was OLED_BLACK
    print_number(menuPage_idx + 1, find_digits(menuPage_idx + 1), 28, 255, OLED_FONT_LARGE);

    print(84, 38, OLED_FONT_SMALL, OLED_WHITE, SLOT_LABEL[0]);   // was OLED_BLACK
    print_number(slot_numb, find_digits(slot_numb), 255, 1, OLED_FONT_LARGE); 
        
    print(
        center_x(sizeof(STR_PRODUCT_NAME) - 1, OLED_FONT_SMALL_WIDTH),
        52,
        OLED_FONT_SMALL,
        OLED_WHITE,
        STR_PRODUCT_NAME[0]
    );

    // ---- Render the option value text ---------------------------
    if (f_option == 1) {
            if (f_toggle == 1) {
                print(center_x(sizeof(ON) - 1, OLED_FONT_SMALL_WIDTH), SINGLE, OLED_FONT_SMALL, OLED_WHITE, ON[0]);
            } else {
                print(center_x(sizeof(OFF) - 1, OLED_FONT_SMALL_WIDTH), SINGLE, OLED_FONT_SMALL, OLED_WHITE, OFF[0]);
            }
            return;
        }

    if (f_option == ShotModOptions) {  // 31
        if (f_toggle == 0)
            print(center_x(sizeof(ModOption_31_0) - 1, OLED_FONT_SMALL_WIDTH), SINGLE, OLED_FONT_SMALL, OLED_WHITE, ModOption_31_0[0]);
        else if (f_toggle == 1)
            print(center_x(sizeof(ModOption_31_1) - 1, OLED_FONT_SMALL_WIDTH), SINGLE, OLED_FONT_SMALL, OLED_WHITE, ModOption_31_1[0]);
        else if (f_toggle == 2)
            print(center_x(sizeof(ModOption_31_2) - 1, OLED_FONT_SMALL_WIDTH), SINGLE, OLED_FONT_SMALL, OLED_WHITE, ModOption_31_2[0]);
        else if (f_toggle == 3)
            print(center_x(sizeof(ModOption_31_3) - 1, OLED_FONT_SMALL_WIDTH), SINGLE, OLED_FONT_SMALL, OLED_WHITE, ModOption_31_3[0]);
        return;
    }

    if (f_option == FireModOptions) {  // 9
        if (f_toggle == 0)
            print(center_x(sizeof(ModOption_31_0) - 1, OLED_FONT_SMALL_WIDTH), SINGLE, OLED_FONT_SMALL, OLED_WHITE, ModOption_31_0[0]);
        else if (f_toggle == 1)
            print(center_x(sizeof(ModOption_31_1) - 1, OLED_FONT_SMALL_WIDTH), SINGLE, OLED_FONT_SMALL, OLED_WHITE, ModOption_31_1[0]);
        else if (f_toggle == 2)
            print(center_x(sizeof(ModOption_31_2) - 1, OLED_FONT_SMALL_WIDTH), SINGLE, OLED_FONT_SMALL, OLED_WHITE, ModOption_31_2[0]);
        else if (f_toggle == 3)
            print(center_x(sizeof(ModOption_31_4) - 1, OLED_FONT_SMALL_WIDTH), SINGLE, OLED_FONT_SMALL, OLED_WHITE, ModOption_31_4[0]);
        return;
    }

    if (f_option == 50) {  // VMSPEED ms
        if (f_toggle == 0)
            print(center_x(sizeof(ModOption_50_0) - 1, OLED_FONT_SMALL_WIDTH), SINGLE, OLED_FONT_SMALL, OLED_WHITE, ModOption_50_0[0]);
        else if (f_toggle == 1)
            print(center_x(sizeof(ModOption_50_1) - 1, OLED_FONT_SMALL_WIDTH), SINGLE, OLED_FONT_SMALL, OLED_WHITE, ModOption_50_1[0]);
        else if (f_toggle == 2)
            print(center_x(sizeof(ModOption_50_2) - 1, OLED_FONT_SMALL_WIDTH), SINGLE, OLED_FONT_SMALL, OLED_WHITE, ModOption_50_2[0]);
        else if (f_toggle == 3)
            print(center_x(sizeof(ModOption_50_3) - 1, OLED_FONT_SMALL_WIDTH), SINGLE, OLED_FONT_SMALL, OLED_WHITE, ModOption_50_3[0]);
        else if (f_toggle == 4)
            print(center_x(sizeof(ModOption_50_4) - 1, OLED_FONT_SMALL_WIDTH), SINGLE, OLED_FONT_SMALL, OLED_WHITE, ModOption_50_4[0]);
        else if (f_toggle == 5)
            print(center_x(sizeof(ModOption_50_5) - 1, OLED_FONT_SMALL_WIDTH), SINGLE, OLED_FONT_SMALL, OLED_WHITE, ModOption_50_5[0]);
        return;
    }

    // Fallback
    else {
        print(center_x(sizeof(OFF) - 1, OLED_FONT_SMALL_WIDTH), SINGLE, OLED_FONT_SMALL, OLED_WHITE, OFF[0]);
    }
}

/* 
////////////// MENU BUTTON ARRAY (RIGHT/LEFT/UP/DOWN/JUMP/MELEE/MENU/AIM) ////// 
PURPOSE:
    NORMALIZED MAP OF UI KEYS USED BY MENU TIMEOUT WATCHDOG.
*/
int MenuButtons[8];
int menu_btn_indx;
int MenuTimeOut;
define menu_time_active = 30000;

/* 
////////////// MENU TIMEOUT WATCHDOG (CLOSES UI ON INACTIVITY) //////////////////
PURPOSE:
    RESETS TIMEOUT WHEN ANY MENU KEY IS PRESSED; CLOSES UI WHEN TIMER ELAPSES.
*/
function CheckIfBtnIsPressed (){  
    for(menu_btn_indx = 0; menu_btn_indx < 8; menu_btn_indx++){
        if(event_press(MenuButtons[menu_btn_indx]) ){
            MenuTimeOut = menu_time_active;
        }
        if(MenuTimeOut){              
            MenuTimeOut -=1;
            if(MenuTimeOut <= 0 ){    
                HOTHACKE = FALSE;      
                HOTHACKER54545454 = FALSE;      
                HOTHACKER54545  = FALSE;  
            }
        }
    }
}

function vcenter_y(font_size) {
    // Centers a line vertically for the given font in a 64-px tall OLED
    return (64 - FONT_STATS[font_size][FONT_STATS_INDEX_HEIGHT]) / 2;
}

/* 
////////////// ABOUT PAGE: PRODUCT NAME + VERSION CENTERED //////////////////////
PURPOSE:
    SIMPLE READ-ONLY PAGE SHOWING STR_PRODUCT_NAME AND STR_PRODUCT_VER.
*/
function display_about_page() {
    cls_oled(0);
    // product + version only
    print(center_x(sizeof(STR_PRODUCT_NAME) - 1, OLED_FONT_MEDIUM_WIDTH), 18, OLED_FONT_MEDIUM, OLED_WHITE, STR_PRODUCT_NAME[0]);
    print(center_x(sizeof(STR_PRODUCT_VER)  - 1, OLED_FONT_MEDIUM_WIDTH), 38, OLED_FONT_MEDIUM, OLED_WHITE, STR_PRODUCT_VER[0]);
}  

/*
////////////// VENOMBYTE BANNER: VERSION + BRAND CENTERED //////////////////////
PURPOSE:
    DISPLAYS THE "VENOMBYTE" BRAND BANNER ON THE OLED WHEN ENABLED.
*/
function draw_venombyte_banner() {
    if(!KEEP_BRAND) return;
    // horizontally & vertically center for MEDIUM font
    print(
        centerPosition(getStringLength(MiscString[1]), OLED_FONT_MEDIUM_WIDTH),
        vcenter_y(OLED_FONT_MEDIUM),
        OLED_FONT_MEDIUM,
        OLED_WHITE,
        MiscString[1]   // "VENOMBYTE"
    );
}